//
//  ExploreWorker.swift
//  Explore
//
//  Created by Christian Graver on 16/12/2018.
//  Copyright (c) 2018 nordgrus. All rights reserved.
//
//  This file was generated by the Daman Clean Swift Xcode Templates
//  with inspiration from http://clean-swift.com
//

import UIKit
import CoreLocation
import AVFoundation

protocol Explorable: class {
    func locationUpdated(location: CLLocation)
    func nearestDiscoveryDistance(_ distance: Double)
    func hitDiscovery(_ discovery: Discovery)
}

class ExploreWorker: NSObject {
    // Properties
    let service: CastService
    weak var delegate: Explorable?
    var foundDiscoveryIds: Set = Set<String>()
    
    private let locationManager = LocationManager.shared
    private var points: [Discovery]?
    var audioPlayer: AVAudioPlayer?
    
    // Vibration related
    var counter = 0
    var timer : Timer?
    
    init(service: CastService) {
        self.service = service
        
    }
    
    func fetchAdventure(completion: @escaping (Cast) -> Void) {
        service.getCast(with: "randomID") { (adventure) in
            completion(adventure)
        }
    }
    
    func startMonitor(discoveryPoints: [Discovery]) {
        self.points = discoveryPoints
        setupLocationManager()
       
    }
    
    func pauseMonitorDiscoveryPoints() {
        locationManager.stopUpdatingLocation()
    }
    
    func stopMonitorDiscoveryPoints() {
        locationManager.stopUpdatingLocation()
    }
    
    func debugHitDiscovery() {
        guard let discovery = self.points?.first else { return }
        playAudio(for: discovery)
    }
    
    private func setupLocationManager() {
        locationManager.delegate = self
        locationManager.activityType = .fitness
        locationManager.allowsBackgroundLocationUpdates = true
      locationManager.distanceFilter = 10
        locationManager.requestAlwaysAuthorization()
        locationManager.startUpdatingLocation()
    }
    
    private func vibrate() {
        // Alert for an upcoming sound clip with vibration
        
        //let generator = UIImpactFeedbackGenerator(style: .heavy)
        //generator.impactOccurred()
        
        //let generator = UINotificationFeedbackGenerator()
        //generator.notificationOccurred(.warning)
        
        counter = 0
        timer = Timer.scheduledTimer(timeInterval: 0.25,
                                     target: self,
                                     selector: #selector(customFeedback), userInfo: nil, repeats: true)
    }
    
    @objc private func customFeedback() {
        counter += 1
        switch counter {
        case 1, 3, 5:
            let medium = UIImpactFeedbackGenerator(style: .light)
            medium.prepare()
            medium.impactOccurred()
        case 2, 4, 6:
            let error = UINotificationFeedbackGenerator()
            error.prepare()
            error.notificationOccurred(.warning)
        default:
            timer?.invalidate()
        }
    }
    
    // Sound test
    @objc private func playUsingAVAudioPlayer(url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.play()
            print("audio played")
        } catch {
            print(error)
            print("audio not played")
        }
    }
    private func playAudio(for discovery: Discovery) {
        // We need url to audio
        guard let urlString = discovery.clip?.urlString,
            let filePath = Bundle.main.path(forResource: urlString, ofType: "m4a") else {
            print("File does not exist in the bundle.")
            return
        }
        
        // First vibrate to warn on upcoming audio
        vibrate()
        
        // Wait 3 sec and play audio
        DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) {
            let url = URL(fileURLWithPath: filePath)
           self.playUsingAVAudioPlayer(url: url)
        }
    }

}

extension ExploreWorker: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let lastLocation = locations.last else { return }
         print("Got location: \(lastLocation)")
        guard lastLocation.horizontalAccuracy < 66 && lastLocation.timestamp.timeIntervalSinceNow < 5 else { return }
        delegate?.locationUpdated(location: lastLocation)
        
        guard let disoveryPoints = self.points, !disoveryPoints.isEmpty else { return }
        var nearestDistance: Double = 0.0
        
        for disovery in disoveryPoints {
            guard !foundDiscoveryIds.contains(disovery.id) else { continue }
            let disoveryLocation = CLLocation(latitude: disovery.location.latitude, longitude: disovery.location.longitude)
            let distance = lastLocation.distance(from: disoveryLocation)
            nearestDistance = nearestDistance < distance ? distance : nearestDistance
            print("distance to point: \(distance)")
            if distance < 20 {
                //We hit a disoveryPoint
                print("We hit a disoveryPoint with id: \(disovery.id)!")
                self.delegate?.hitDiscovery(disovery)
                foundDiscoveryIds.insert(disovery.id)
                playAudio(for: disovery)
            }
        }
        delegate?.nearestDiscoveryDistance(nearestDistance)
    }
}
